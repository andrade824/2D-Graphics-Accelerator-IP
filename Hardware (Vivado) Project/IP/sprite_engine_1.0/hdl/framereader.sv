`timescale 1 ns / 1 ps

module framereader #
(
    // Users to add parameters here

    // User parameters ends
    // Do not modify the parameters beyond this line

    // Burst Length. Supports 1, 2, 4, 8, 16, 32, 64, 128, 256 burst lengths
    parameter integer C_M_AXI_BURST_LEN = 16,
    // Width of Address Bus
    parameter integer C_M_AXI_ADDR_WIDTH = 32,
    // Width of Data Bus
    parameter integer C_M_AXI_DATA_WIDTH = 32
)
(
    /* Signals coming from VGA Controller */
    input logic pixel_clk,  // The clock at which pixels are being sent to the screen
    input logic next_pixel_please,  // Asserted when VGA controllers wants next pixel from FIFO
    output logic [31:0] pixel_data, // The output of the FIFO
    input logic end_of_frame, // Asserted when a whole frame has been displayed
    
    // Signals coming from Engine Controller
    input logic [31:0] base_addr,
    input logic enable,
    
    /* GENERIC SIGNALS */
    // Global Clock Signal.
    input logic  M_AXI_ACLK,
    // Global Reset Signal. This Signal is Active Low
    input logic  M_AXI_ARESETN,

    /* READ ADDRESS */
    // Master Interface Read Address.
    output logic M_AXI_ARID,
    // Read address. This signal indicates the initial
    // address of a read burst transaction.
    output logic [C_M_AXI_ADDR_WIDTH-1 : 0] M_AXI_ARADDR,
    // Burst length. The burst length gives the exact number of transfers in a burst
    output logic [3 : 0] M_AXI_ARLEN,
    // Burst size. This signal indicates the size of each transfer in the burst
    output logic [2 : 0] M_AXI_ARSIZE,
    // Burst type. The burst type and the size information,
    // determine how the address for each transfer within the burst is calculated.
    output logic [1 : 0] M_AXI_ARBURST,
    // Lock type. Provides additional information about the
    // atomic characteristics of the transfer.
    output logic  M_AXI_ARLOCK,
    // Memory type. This signal indicates how transactions
    // are required to progress through a system.
    output logic [3 : 0] M_AXI_ARCACHE,
    // Protection type. This signal indicates the privilege
    // and security level of the transaction, and whether
    // the transaction is a data access or an instruction access.
    output logic [2 : 0] M_AXI_ARPROT,
    // Quality of Service, QoS identifier sent for each read transaction
    output logic [3 : 0] M_AXI_ARQOS,
    // Write address valid. This signal indicates that
    // the channel is signaling valid read address and control information
    output logic  M_AXI_ARVALID,
    // Read address ready. This signal indicates that
    // the slave is ready to accept an address and associated control signals
    input logic  M_AXI_ARREADY,

    /* READ DATA */
    // Read ID tag. This signal is the identification tag
    // for the read data group of signals generated by the slave.
    input logic M_AXI_RID,
    // Master Read Data
    input logic [C_M_AXI_DATA_WIDTH-1 : 0] M_AXI_RDATA,
    // Read response. This signal indicates the status of the read transfer
    input logic [1 : 0] M_AXI_RRESP,
    // Read last. This signal indicates the last transfer in a read burst
    input logic  M_AXI_RLAST,
    // Read valid. This signal indicates that the channel
    // is signaling the required read data.
    input logic  M_AXI_RVALID,
    // Read ready. This signal indicates that the master can
    // accept the read data and response information.
    output logic  M_AXI_RREADY
);

    // function called clogb2 that returns an integer which has the
    // value of the ceiling of the log base 2.
    function integer clogb2 (input integer bit_depth);
    begin
        for(clogb2=0; bit_depth>0; clogb2=clogb2+1)
            bit_depth = bit_depth >> 1;
    end
    endfunction

    // C_TRANSACTIONS_NUM is the width of the index counter for
    // number of write or read transaction.
    localparam integer C_TRANSACTIONS_NUM = clogb2(C_M_AXI_BURST_LEN-1);

    // Receive logic state machine variables
    typedef enum logic[1:0] {WAIT, START_BURST, READ, CLEAR_ALL} receive_state;
    receive_state current_state, next_state;

    // The current offset at which to read pixels from
    logic [C_M_AXI_ADDR_WIDTH - 1 : 0] addr_offset;
    
    // AXI4 internal temp signals (I could probably get rid of these)
    logic axi_arvalid;
    logic axi_rready;

    //size of C_M_AXI_BURST_LEN length burst in bytes
    logic [C_TRANSACTIONS_NUM + 2 : 0] burst_size_bytes;

    // Asserted when starting a burst read transfer (no shit)
    logic start_single_burst_read;
    
    // Asserted when we've received a new piece of data
    logic rnext;

    // Asserted when the FIFO is almost full (within 32 words)
    logic fifo_almostfull;

    // Used to asynchronously reset various components in this module
    logic frame_sync;
    logic [4:0] reset_counter;
    logic async_clear;

    // Burst size in bytes (number of words being bursted * length of words in bytes)
    assign burst_size_bytes = C_M_AXI_BURST_LEN * (C_M_AXI_DATA_WIDTH / 8);

    // AXI Signal Connections (most of these signals are unused or need to be tied to a certain value)
    // Check section A2 of the AXI Spec for descriptions of these signals and the values

    /* Read Address (AR) */
    assign M_AXI_ARID = 'b0;
    assign M_AXI_ARADDR = base_addr + addr_offset;
    //Burst LENgth is number of transaction beats, minus 1
    assign M_AXI_ARLEN = C_M_AXI_BURST_LEN - 1;
    //Size should be C_M_AXI_DATA_WIDTH, in 2^n bytes, otherwise narrow bursts are used
    assign M_AXI_ARSIZE = clogb2((C_M_AXI_DATA_WIDTH/8)-1);
    
    assign M_AXI_ARBURST = 2'b01;  // INCR burst type (address will auto-increment for each word being bursted)
    assign M_AXI_ARLOCK = 1'b0;
    //Update value to 4'b0011 if coherent accesses to be used via the Zynq ACP port. Not Allocated, Modifiable, not Bufferable. Not Bufferable since this example is meant to test memory, not intermediate cache.
    assign M_AXI_ARCACHE = 4'b0010;
    assign M_AXI_ARPROT = 3'h0;
    assign M_AXI_ARQOS = 4'h0;
    assign M_AXI_ARVALID = axi_arvalid;

    /* Read Data and Read Response (R) */
    assign M_AXI_RREADY = axi_rready;
    
    //----------------------------
    //Read Address Channel
    //----------------------------
    
    /**
    * Waits until the start_single_burst_read signal gets asserted (by the state machine)
    * then transfers the address over to the slave.
    */
    always @(posedge M_AXI_ACLK)
    begin
        if (!M_AXI_ARESETN || async_clear)
            axi_arvalid <= 1'b0;
        else if (~axi_arvalid && start_single_burst_read)
            axi_arvalid <= 1'b1;    // If previously not valid , start next transaction
        else if (M_AXI_ARREADY && axi_arvalid)
            axi_arvalid <= 1'b0;
        else
            axi_arvalid <= axi_arvalid;
    end

    /*
    * After the address is received by the slave, increment it so it's
    * ready to go for the next burst transfer
    */
    always @(posedge M_AXI_ACLK)
    begin
        if (!M_AXI_ARESETN || async_clear)
            addr_offset <= 'b0;
        else if (M_AXI_ARREADY && axi_arvalid)
            addr_offset <= addr_offset + burst_size_bytes;
        else
            addr_offset <= addr_offset;
    end


    //--------------------------------
    //Read Data (and Response) Channel
    //--------------------------------
    
    // Forward movement occurs when the channel is valid and ready
    assign rnext = M_AXI_RVALID && axi_rready;

    /*
    * Assert that we're ready to receive data whenever the slave
    * says they have valid data available (until we've received 
    * the last piece of data).
    */
    always @(posedge M_AXI_ACLK)
    begin
        if (!M_AXI_ARESETN || async_clear) begin
            axi_rready <= 1'b0;
        end
        else if (M_AXI_RVALID) begin
            if (M_AXI_RLAST && axi_rready) begin
                axi_rready <= 1'b0;
            end else begin
                axi_rready <= 1'b1;
            end
        end else begin
            axi_rready <= axi_rready;
        end
    end

    // Dual-clock FIFO to transfer data between framereader and VGA controller clock domains
    FIFO36E1 #(
        .ALMOST_EMPTY_OFFSET(13'h0020), // Sets the almost empty threshold
        .ALMOST_FULL_OFFSET(13'h0020), // Sets almost full threshold
        .DATA_WIDTH(36), // Sets data width to 4-72
        .DO_REG(1), // Enable output register (1-0) Must be 1 if EN_SYN = FALSE
        .EN_ECC_READ("FALSE"), // Enable ECC decoder, FALSE, TRUE
        .EN_ECC_WRITE("FALSE"), // Enable ECC encoder, FALSE, TRUE
        .EN_SYN("FALSE"), // Specifies FIFO as Asynchronous (FALSE) or Synchronous (TRUE)
        .FIFO_MODE("FIFO36"), // Sets mode to "FIFO36" or "FIFO36_72"
        .FIRST_WORD_FALL_THROUGH("FALSE"), // Sets the FIFO FWFT to FALSE, TRUE
        .INIT(72'h000000000000000000), // Initial values on output port
        .SIM_DEVICE("7SERIES"), // Must be set to "7SERIES" for simulation behavior
        .SRVAL(72'h000000000000000000) // Set/Reset value for output port
    ) FIFO36E1_inst (
        // ECC Signals: 1-bit (each) output: Error Correction Circuitry ports
        .DBITERR(), // 1-bit output: Double bit error status
        .ECCPARITY(), // 8-bit output: Generated error correction parity
        .SBITERR(), // 1-bit output: Single bit error status
        
        // Read Data: 64-bit (each) output: Read output data
        .DO(pixel_data), // 64-bit output: Data output
        .DOP(), // 8-bit output: Parity data output
        
        // Status: 1-bit (each) output: Flags and other FIFO status outputs
        .ALMOSTEMPTY(), // 1-bit output: Almost empty flag
        .ALMOSTFULL(fifo_almostfull), // 1-bit output: Almost full flag
        .EMPTY(), // 1-bit output: Empty flag
        .FULL(), // 1-bit output: Full flag
        .RDCOUNT(), // 13-bit output: Read count
        .RDERR(), // 1-bit output: Read error
        .WRCOUNT(), // 13-bit output: Write count
        .WRERR(), // 1-bit output: Write error
        
        // ECC Signals: 1-bit (each) input: Error Correction Circuitry ports
        .INJECTDBITERR(), // 1-bit input: Inject a double bit error input
        .INJECTSBITERR(),
        
        // Read Control Signals: 1-bit (each) input: Read clock, enable and reset input signals
        .RDCLK(pixel_clk), // 1-bit input: Read clock
        .RDEN(next_pixel_please), // 1-bit input: Read enable
        .REGCE(1'b1), // 1-bit input: Clock enable
        .RST(async_clear), // 1-bit input: Reset
        .RSTREG(1'b0), // 1-bit input: Output register set/reset
        
        // Write Control Signals: 1-bit (each) input: Write clock and enable input signals
        .WRCLK(M_AXI_ACLK), // 1-bit input: Rising edge write clock.
        .WREN(rnext), // 1-bit input: Write enable
        
        // Write Data: 64-bit (each) input: Write input data
        .DI(M_AXI_RDATA), // 64-bit input: Data input
        .DIP() // 8-bit input: Parity input
    );

    // State changing logic
    always_ff @(negedge M_AXI_ACLK) begin
        if(!M_AXI_ARESETN)
            current_state <= WAIT;
        else
            current_state <= next_state;
    end

    // Next-state and output-forming logic
    always_comb begin
        next_state = current_state;
        start_single_burst_read = 1'b0;
        async_clear = 1'b0;
        
        case(current_state)
            // Read the FIFO fill level and wait until it's not full
            WAIT : begin
                if(!enable)
                    next_state = WAIT;
                else if(frame_sync)
                    next_state = CLEAR_ALL;
                else if(!fifo_almostfull)
                    next_state = START_BURST;
            end

            // Start the burst read transaction
            START_BURST : begin
                start_single_burst_read = 1'b1;
                next_state = READ;
            end

            // Wait until the burst transfer has completed
            READ : begin
                // Move to the WAIT state after the last data beat has transferred
                if(M_AXI_RVALID && axi_rready && M_AXI_RLAST)
                    next_state = WAIT;
            end

            /* 
            * Clear out the FIFO and address offsets. This to set-up for reading 
            * the next video frame (we don't want remnants of the old frame to 
            * show up on the new one).
            */
            CLEAR_ALL : begin
                async_clear = 1'b1;
                
                if(reset_counter == 5'd31)
                    next_state = WAIT;
            end
        endcase
    end

    /* Reset Logic (when the end of frame occurs) */
    
    // Capture the end_of_frame signal so it can be processed after a burst transfer is done
    always_ff @(posedge M_AXI_ACLK) begin
        if(!M_AXI_ARESETN || async_clear)
            frame_sync <= '0;
        else if (end_of_frame)
            frame_sync <= 1'b1;
        else
            frame_sync <= frame_sync;
    end
    
    /*
    * For whatever stupid reason, Xilinx FIFO modules require
    * the reset line to be asserted for at least 5 clock cycles.
    * This counter makes sure the reset is asserted (more than) long enough.
    */
    always_ff @(posedge M_AXI_ACLK) begin
        if(!M_AXI_ARESETN)
            reset_counter <= '0;
        else if(current_state == CLEAR_ALL)
            reset_counter <= reset_counter + 1'b1;
        else
            reset_counter <= '0;
    end
endmodule