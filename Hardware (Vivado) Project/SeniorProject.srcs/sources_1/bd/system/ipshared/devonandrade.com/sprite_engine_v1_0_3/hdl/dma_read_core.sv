`timescale 1 ns / 1 ps

module dma_read_core #
(
    // Burst Length. Supports 1, 2, 4, 8, 16, 32, 64, 128, 256 burst lengths
    parameter integer C_M_AXI_MAX_BURST_LEN = 16,
    // Width of Address Bus
    parameter integer C_M_AXI_ADDR_WIDTH = 32,
    // Width of Data Bus
    parameter integer C_M_AXI_DATA_WIDTH = 32
)
(
    // DMA Signals
    input logic start, 
    output logic done,
    input logic [31:0] source_addr,
    input logic [20:0] size_in_bytes,
    
    // FIFO signals
    output logic [31:0] fifo_wdata,
    input logic fifo_full,
    output logic fifo_wren,

    /* GENERIC SIGNALS */
    // Global Clock Signal.
    input logic M_AXI_ACLK,
    // Global Reset Signal. This Signal is Active Low
    input logic M_AXI_ARESETN,

    /* READ ADDRESS */
    // Master Interface Read Address.
    output logic M_AXI_ARID,
    // Read address. This signal indicates the initial
    // address of a read burst transaction.
    output logic [C_M_AXI_ADDR_WIDTH-1:0] M_AXI_ARADDR,
    // Burst length. The burst length gives the exact number of transfers in a burst
    output logic [3:0] M_AXI_ARLEN,
    // Burst size. This signal indicates the size of each transfer in the burst
    output logic [2:0] M_AXI_ARSIZE,
    // Burst type. The burst type and the size information,
    // determine how the address for each transfer within the burst is calculated.
    output logic [1:0] M_AXI_ARBURST,
    // Lock type. Provides additional information about the
    // atomic characteristics of the transfer.
    output logic M_AXI_ARLOCK,
    // Memory type. This signal indicates how transactions
    // are required to progress through a system.
    output logic [3:0] M_AXI_ARCACHE,
    // Protection type. This signal indicates the privilege
    // and security level of the transaction, and whether
    // the transaction is a data access or an instruction access.
    output logic [2:0] M_AXI_ARPROT,
    // Quality of Service, QoS identifier sent for each read transaction
    output logic [3:0] M_AXI_ARQOS,
    // Write address valid. This signal indicates that
    // the channel is signaling valid read address and control information
    output logic M_AXI_ARVALID,
    // Read address ready. This signal indicates that
    // the slave is ready to accept an address and associated control signals
    input logic M_AXI_ARREADY,

    /* READ DATA */
    // Read ID tag. This signal is the identification tag
    // for the read data group of signals generated by the slave.
    input logic M_AXI_RID,
    // Master Read Data
    input logic [C_M_AXI_DATA_WIDTH-1:0] M_AXI_RDATA,
    // Read response. This signal indicates the status of the read transfer
    input logic [1:0] M_AXI_RRESP,
    // Read last. This signal indicates the last transfer in a read burst
    input logic M_AXI_RLAST,
    // Read valid. This signal indicates that the channel
    // is signaling the required read data.
    input logic M_AXI_RVALID,
    // Read ready. This signal indicates that the master can
    // accept the read data and response information.
    output logic M_AXI_RREADY
);

    // function called clogb2 that returns an integer which has the
    // value of the ceiling of the log base 2.
    function integer clogb2 (input integer bit_depth);
    begin
        for(clogb2=0; bit_depth>0; clogb2=clogb2+1)
            bit_depth = bit_depth >> 1;
    end
    endfunction

    // This is how many bits it takes to store the maximum burst length number in binary
    localparam integer BITS_FOR_BURST = clogb2(C_M_AXI_MAX_BURST_LEN - 1);

    // Receive logic state machine variables
    typedef enum logic[1:0] {START, START_BURST, READ} read_state;
    read_state current_state, next_state;

    // The current offset at which to read pixels from
    logic [20:0] addr_offset;
    
    // AXI4 internal temp signals (I could probably get rid of these)
    logic axi_arvalid;
    logic axi_rready;

    // Size of C_M_AXI_MAX_BURST_LEN length burst in bytes
    logic [BITS_FOR_BURST + 2:0] burst_size_bytes;

    // How many bytes need to be read
    logic [20:0] bytes_left;

    // How many "beats" to burst in the next transaction
    logic [4:0] burst_length;

    // Asserted when starting a burst read transfer (no shit)
    logic start_single_burst_read;

    // How many "beats" to burst by (each beat is two pixels)
    assign bytes_left = size_in_bytes - addr_offset;
    assign burst_length = (bytes_left >= (C_M_AXI_MAX_BURST_LEN << 2)) ? C_M_AXI_MAX_BURST_LEN : (bytes_left >> 2);

    // Burst size in bytes
    assign burst_size_bytes = burst_length << 2;

    // AXI Signal Connections (most of these signals are unused or need to be tied to a certain value)
    // Check section A2 of the AXI Spec for descriptions of these signals and the values

    /* Read Address (AR) */
    assign M_AXI_ARID = 'b0;
    assign M_AXI_ARADDR = source_addr + addr_offset;
    // Burst LENgth is number of transaction beats, minus 1
    assign M_AXI_ARLEN = burst_length - 1;
    // Size should be C_M_AXI_DATA_WIDTH, in 2^n bytes, otherwise narrow bursts are used
    assign M_AXI_ARSIZE = clogb2((C_M_AXI_DATA_WIDTH/8)-1);
    
    assign M_AXI_ARBURST = 2'b01;  // INCR burst type (address will auto-increment for each word being bursted)
    assign M_AXI_ARLOCK = 1'b0;
    // Update value to 4'b0011 if coherent accesses to be used via the Zynq ACP port. Not Allocated, Modifiable, not Bufferable.
    assign M_AXI_ARCACHE = 4'b0010;
    assign M_AXI_ARPROT = 3'h0;
    assign M_AXI_ARQOS = 4'h0;
    assign M_AXI_ARVALID = axi_arvalid;

    /* Read Data and Read Response (R) */
    assign M_AXI_RREADY = axi_rready;
    
    //----------------------------
    // Read Address Channel
    //----------------------------
    
    /**
    * Waits until the start_single_burst_read signal gets asserted (by the state machine)
    * then transfers the address over to the slave.
    */
    always @(posedge M_AXI_ACLK)
    begin
        if (!M_AXI_ARESETN)
            axi_arvalid <= 1'b0;
        else if (~axi_arvalid && start_single_burst_read)
            axi_arvalid <= 1'b1;    // If previously not valid , start next transaction
        else if (M_AXI_ARREADY && axi_arvalid)
            axi_arvalid <= 1'b0;
        else
            axi_arvalid <= axi_arvalid;
    end

    /*
    * After the address is received by the slave, increment it so it's
    * ready to go for the next burst transfer
    */
    always @(posedge M_AXI_ACLK)
    begin
        if (!M_AXI_ARESETN || (start && current_state == START))
            addr_offset <= 'b0;
        else if (M_AXI_ARREADY && axi_arvalid)
            addr_offset <= addr_offset + burst_size_bytes;
        else
            addr_offset <= addr_offset;
    end


    //--------------------------------
    // Read Data (and Response) Channel
    //--------------------------------
    
    // Forward movement occurs when the channel is valid and ready
    assign fifo_wren = M_AXI_RVALID && axi_rready;
    assign fifo_wdata = M_AXI_RDATA;

    /*
    * Assert that we're ready to receive data whenever the slave
    * says they have valid data available and the FIFO isn't full.
    */
    always @(posedge M_AXI_ACLK)
    begin
        if (!M_AXI_ARESETN) begin
            axi_rready <= 1'b0;
        end else if (M_AXI_RVALID && !fifo_full) begin
            axi_rready <= 1'b1;
        end else begin
            axi_rready <= 1'b0;
        end
    end

    //--------------------------------
    // Control State Machine
    //--------------------------------

    // State changing logic
    always_ff @(posedge M_AXI_ACLK) begin
        if(!M_AXI_ARESETN)
            current_state <= START;
        else
            current_state <= next_state;
    end

    // Next-state and output-forming logic
    always_comb begin
        next_state = current_state;
        start_single_burst_read = 1'b0;
        done = 1'b0;

        case(current_state)
            // Once the start signal is received, start the burst read
            START : begin
                done = 1'b1;

                if(start)
                    next_state = START_BURST;
            end

            // Start the burst read transaction
            START_BURST : begin
                start_single_burst_read = 1'b1;
                next_state = READ;
            end

            // Wait until the burst transfer has completed
            READ : begin
                // Move to the start state after the last data beat has transferred
                if(M_AXI_RVALID && axi_rready && M_AXI_RLAST) begin
                    if(addr_offset >= size_in_bytes)
                        next_state = START;
                    else
                        next_state = START_BURST;
                end
            end
        endcase
    end

endmodule